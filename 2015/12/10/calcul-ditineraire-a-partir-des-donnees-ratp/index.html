<!DOCTYPE html>
<html lang="fr">
  <head>
        <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=endge, chrome=IE8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=no" />
    <title>Calcul d'itinéraire à partir des données RATP — Blog bloquant</title>
    <!--[if lte IE 8]><script type="text/javascript" src="https://www.dericbourg.net/theme/js/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" type="text/css" href="https://www.dericbourg.net/theme/css/skeleton.css" />
    <link rel="stylesheet" type="text/css" href="https://www.dericbourg.net/theme/css/theme.css" />
    <link rel="shortcut icon" type="image/png" href="https://www.dericbourg.net/favicon.png" />
    <!--[if lte IE 8]><link rel="shortcut icon" type="image/x-icon" href="https://www.dericbourg.net/favicon.ico" /><![endif]-->
    <link rel="alternate" type="application/atom+xml"
                           title="Blog bloquant — Flux Atom"
                           href="https://www.dericbourg.net/" /> 

    <meta name="author"   content="Alban Dericbourg" />
    <meta name="keywords" content="opendata, ratp, gtfs, scala" />
    <link rel="stylesheet" media="not print" type="text/css" href="https://www.dericbourg.net/theme/css/pygments.css" /> 
  </head>
  <body>
    <div id="page">
      <header id="page-head">
        <h1>
          <a href="https://www.dericbourg.net/index.html">Blog bloquant</a>
        </h1>
      </header>
      
      <div id="page-body">
        <article class="post" id="page-main" role="main">
      <header class="post-header">
        <h1>
          <a rel="bookmark"
             href="https://www.dericbourg.net/2015/12/10/calcul-ditineraire-a-partir-des-donnees-ratp/"
             title="Lien permanent vers «Calcul d'itinéraire à partir des données RATP»">
             Calcul d'itinéraire à partir des données RATP
          </a>
        </h1>
        <div class="meta">
<!-- includes/article_meta.html -->
            Le <time datetime="2015-12-10T00:00:00+01:00">Thu 10 December 2015</time>
            dans «<a href="https://www.dericbourg.net/category/blog.html">Blog</a>» 
            par <a href="https://www.dericbourg.net/author/alban-dericbourg.html">Alban Dericbourg</a>              <br />Mots-clés:              <a rel="tag" href="https://www.dericbourg.net/tag/opendata.html">opendata</a>,               <a rel="tag" href="https://www.dericbourg.net/tag/ratp.html">ratp</a>,               <a rel="tag" href="https://www.dericbourg.net/tag/gtfs.html">gtfs</a>,               <a rel="tag" href="https://www.dericbourg.net/tag/scala.html">scala</a>        </div>
      </header>
      <div class="post-content"> 
        <p>La RATP progresse dans l'<a href="http://data.ratp.fr">ouverture de ses données</a> et même si elle ne propose pas encore un accès à son <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_d'information_en_ligne">système SIEL</a>, elle propose néanmoins les données de son offre de transport au <a href="https://developers.google.com/transit/gtfs/">format GTFS</a>. Une bonne occasion de s'initier au calcul d'itinéraire !</p>
<p>L'histoire et le contexte des calculs d'itinéraires est très bien synthétisé par <a href="https://twitter.com/tristramg">Tristram Gräbener</a> dans son <a href="http://blog.tristramg.eu/petit-historique-du-calcul-ditineraire.html">Petit historique du calcul d'itinéraire</a>. Probablement plus hipster que je ne veux bien l'admettre, j'ai choisi d'utiliser le plus récent : le <em><a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/dpsw-isftr-13.pdf">Connection Scan Algorithm</a></em>.</p>
<h2>Connection scan algorithm</h2>
<blockquote>
<p>Cette explication est largement inspirée de l'explication de l'algorithme du <a href="https://github.com/captaintrain/csa-challenge/blob/master/readme.md">csa-challenge de CaptainTrain</a>.</p>
</blockquote>
<p>Cet algorithme, tenant en quelques lignes, se « contente » de parcourir une table horaire pré-calculée des connexions entre les stations et de retenir la solution optimale en temps de trajet. Une connexion représente une possibilité de trajet entre deux stations. On la modélise donc par un quadruplet contenant :</p>
<ul>
<li>la station de départ,</li>
<li>la station d'arrivée,</li>
<li>l'heure de départ,</li>
<li>l'heure d'arrivée.</li>
</ul>
<p>La table horaire devient alors simplement une liste de ces connexions triées par heure de départ croissante.</p>
<p>Pour chaque station <em>s</em>, on considère l'heure et la station d'arrivée. Si celles-ci sont optimales, on les conserve. Les stations étant identifiées par des entiers, on les conserve dans deux tableaux : <code>arrival_timestamp[s]</code> et <code>in_connection[s]</code>.</p>
<p>L'objectif est de se rendre d'un point de départ <em>o</em> à un point d'arrivée <em>d</em> en partant à l'heure <em>t0</em>.</p>
<h3>Initialisation</h3>
<p>On initialise l'algorithme en attribuant une durée infinie au trajet vers tout point d'arrêt à l'exception de la gare de départ (on en part, on sait qu'on y est à <em>t0</em>).</p>
<div class="highlight"><pre><span></span><code><span class="n">Pour</span><span class="w"> </span><span class="n">chaque</span><span class="w"> </span><span class="n">station</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">    </span><span class="n">arrival_timestamp</span><span class="o">[</span><span class="n">s</span><span class="o">]</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">infinite</span><span class="w"></span>
<span class="w">    </span><span class="n">in_connection</span><span class="o">[</span><span class="n">s</span><span class="o">]</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">invalid_value</span><span class="w"></span>

<span class="n">arrival_timestamp</span><span class="o">[</span><span class="n">o</span><span class="o">]</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">t0</span><span class="w"></span>
</code></pre></div>

<h3>Boucle de calcul</h3>
<p>On parcourt l'ensemble des connexions contenues dans la table et on considère l'amélioration qu'elle apporte sur le trajet. À la fin de la boucle, lorsque toutes les connexions on été parcourues, toutes les heures d'arrivée depuis <em>o</em> vers une autre station ont été calculées.</p>
<div class="highlight"><pre><span></span><code><span class="err">Pour chaque connexion c</span>
<span class="err">    Si arrival_timestamp[c.departure_station] ≤ c.departure_timestamp</span>
<span class="err">    et arrival_timestamp[c.arrival_station] &gt; c.arrival_timestamp</span>
<span class="err">        arrival_timestamp[c.arrival_station] ← c.arrival_timestamp</span>
<span class="err">        in_connection[c.arrival_station] ← c</span>
</code></pre></div>

<h3>Résultat</h3>
<p>Pour obtenir le résultat, on parcourt le tableau des stations d'arrivée (<code>in_connections</code>) en partant de la destination <em>d</em> jusqu'à retrouver le point de départ <em>o</em>.</p>
<h3>Exemple</h3>
<p>Prenons un exemple sur une ligne fictive :</p>
<div class="highlight"><pre><span></span><code><span class="err">         -----o C</span>
<span class="err">       /</span>
<span class="err">o-----o B</span>
<span class="err">A      \</span>
<span class="err">         -----o D</span>
</code></pre></div>

<p>On souhaite rejoindre <code>C</code> depuis <code>A</code> en partant à l'heure 2 avec la table horaire suivante :</p>
<table class="table table-bordered table-condensed table-striped">
<thead>
  <tr>
    <th>Station de départ</th>
    <th>Station d'arrivée</th>
    <th>Heure de départ</th>
    <th>Heure d'arrivée</th>
</thead>
<tbody>
  <tr><td>A</td><td>B</td><td>0</td><td>1</td></tr>
  <tr><td>B</td><td>D</td><td>1</td><td>2</td></tr>
  <tr><td>A</td><td>B</td><td>2</td><td>3</td></tr>
  <tr><td>B</td><td>C</td><td>3</td><td>4</td></tr>
  <tr><td>A</td><td>B</td><td>4</td><td>5</td></tr>
  <tr><td>A</td><td>B</td><td>5</td><td>6</td></tr>
  <tr><td>B</td><td>D</td><td>5</td><td>6</td></tr>
  <tr><td>B</td><td>C</td><td>6</td><td>7</td></tr>
</tbody>
</table>

<p>Initialisons les données.</p>
<table class="table table-condensed">
<thead>
  <tr><th></th> <th>A</th><th>B</th><th>C</th><th>D</th></tr>
</thead>
<tbody>
  <tr><th>Heure</th> <td>2</td><td>&infin;</td><td>&infin;</td><td>&infin;</td></tr>
  <tr><th>Station</th> <td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
</tbody>
</table>

<p>On parcours ensuite la table horaire dans l'ordre. Les deux premières lignes sont ignorées, elles ne passent pas la condition horaire.</p>
<p>On arrive à (A, B, 2, 3) :</p>
<ul>
<li>Heure(A) ≤ 2 (2 ≤ 2)</li>
<li>Heure(B) &gt; 3 (&infin; &gt; 3)</li>
</ul>
<p>On met à jour les tables intermédiaires.</p>
<table class="table table-condensed">
<thead>
  <tr><th></th> <th>A</th><th>B</th><th>C</th><th>D</th></tr>
</thead>
<tbody>
  <tr><th>Heure</th> <td>2</td><td><strong>3</strong></td><td>&infin;</td><td>&infin;</td></tr>
  <tr><th>Station</th> <td>N/A</td><td><strong>(A, B, 2, 3)</strong></td><td>N/A</td><td>N/A</td></tr>
</tbody>
</table>

<p>On continue avec avec (B, C, 3, 4) qui satisfait également les conditions.</p>
<table class="table table-condensed">
<thead>
  <tr><th></th> <th>A</th><th>B</th><th>C</th><th>D</th></tr>
</thead>
<tbody>
  <tr><th>Heure</th> <td>2</td><td>3</td><td><strong>4</strong></td><td>&infin;</td></tr>
  <tr><th>Station</th> <td>N/A</td><td>(A, B, 2, 3)</td><td><strong>(B, C, 3, 4)</strong></td><td>N/A</td></tr>
</tbody>
</table>

<p>Un œil averti aura remarqué que le trajet est ici déterminé. L'algorithme se poursuit néanmoins.</p>
<p>On arrive sur (A, B, 4, 5). On n'a bien Heure(A) ≤ 3 mais en revanche on n'a pas Heure(B) &gt; 4. On passe la connexion. De même pour (A, B, 5, 6).</p>
<p>Vient (B, D, 5, 6) :</p>
<ul>
<li>Heure(B) ≤ 5 (3 ≤ 5)</li>
<li>Heure(D) &gt; 6 (&infin; &gt; 6)</li>
</ul>
<p>Les tableaux sont donc mis à jour.</p>
<table class="table table-condensed">
<thead>
  <tr><th></th> <th>A</th><th>B</th><th>C</th><th>D</th></tr>
</thead>
<tbody>
  <tr><th>Heure</th> <td>2</td><td>3</td><td>4</td><td><strong>6</strong></td></tr>
  <tr><th>Station</th> <td>N/A</td><td>(A, B, 2, 3)</td><td>(B, C, 3, 4)</td><td><strong>(B, D, 5, 6)</strong></td></tr>
</tbody>
</table>

<p>Il reste enfin la connexion (B, C, 6, 7) qui ne remplit par la condition Heure(C) &gt; 7. On ne fait donc rien de cette connexion et les tableaux sont calculés.</p>
<p>Pour obtenir le trajet, on part de la destination, donc de l'entrée associée au point d'arrêt C dans le tableau des stations. On trouve (B, C, 3, 4). On va alors chercher l'entrée associée au départ de cette connexion, soit l'entrée associée à B. On trouve (A, B, 2, 3). Le point de départ de cette connexion est notre point de départ : la recherche est terminée.</p>
<p>En dépilant (<em>Last in, first out</em>) ces connexions, on retrouve le trajet à parcourir :</p>
<ol>
<li>(A, B, 2, 3)</li>
<li>(B, C, 3, 4)</li>
</ol>
<p>L'algorithme nous a donc permis de déterminer le trajet pour aller de A à C en partant à l'heure 2 ainsi que l'heure d'arrivée.</p>
<h3>Analyse</h3>
<p>Cet algorithme présente l'avantage de s'exécuter en un temps proportionnel au nombre de connexions en occupant un espace mémoire lui aussi proportionnel au nombre de connexions. Dans le cas du métro parisien, on peut évaluer que le nombre de correspondances est du même ordre de grandeur que le nombre <em>N</em> de stations. Cela revient à avoir :</p>
<ul>
<li>environ <em>N</em> connexions entre stations d'une même ligne (le chiffre est légèrement faussé par la présence de lignes en « fourche ») ;</li>
<li>environ <em>2N</em> connexions issues des correspondances (une connexion dans un sens, une connexion dans l'autre).</li>
</ul>
<p>L'algorithme a donc une complexité proportionnelle au nombre de stations.</p>
<h2>Exploitation des données de la RATP</h2>
<h3>Format GTFS</h3>
<p>Le format GTFS est un standard et la RATP se conforme à ce standard, simple et bien documenté. Les données sont réparties sur plusieurs fichiers dont nous n'en retiendrons que certains dans cet article.</p>
<h4>routes.txt</h4>
<p>Le fichier décrit le nom et la direction des routes. Une route est assimilable à un trajet (origine - destination).</p>
<p>Prenons l'exemple de la ligne 13 du métro parisien dont le plan simplifié est représenté sur la figure ci-dessous. Cette ligne est parcourue par quatre routes :</p>
<ul>
<li>Châtillon - Montrouge en direction de Saint-Denis Université ;</li>
<li>Châtillon - Montrouge en direction de Gennevilliers Les Courtilles ;</li>
<li>Saint-Denis Université en direction de Châtillon - Montrouge ;</li>
<li>Gennevilliers Les Courtilles en direction de Châtillon - Montrouge.</li>
</ul>
<p><img alt="Plan simplifié de la ligne 13 du métro parisien" class="center" src="/images/connection_scan_algorithm/ligne13.png"></p>
<p>Le fichier <code>routes.txt</code> contient pour cette ligne :</p>
<div class="highlight"><pre><span></span><code><span class="n">route_id</span><span class="p">,</span><span class="n">agency_id</span><span class="p">,</span><span class="n">route_short_name</span><span class="p">,</span><span class="n">route_long_name</span><span class="p">,</span><span class="n">route_desc</span><span class="p">,</span><span class="n">route_type</span><span class="p">,</span><span class="n">route_url</span><span class="p">,</span><span class="n">route_color</span><span class="p">,</span><span class="n">route_text_color</span>
<span class="m">1197620</span><span class="p">,</span><span class="m">100</span><span class="p">,</span><span class="s">&quot;13&quot;</span><span class="p">,</span><span class="s">&quot;(CHATILLON - MONTROUGE &lt;-&gt; ST-DENIS-UNIVERSITE/LES COURTILLES) - Aller&quot;</span><span class="p">,,</span><span class="m">1</span><span class="p">,,</span><span class="n">FFFFFF</span><span class="p">,</span><span class="m">000000</span>
<span class="m">1197621</span><span class="p">,</span><span class="m">100</span><span class="p">,</span><span class="s">&quot;13&quot;</span><span class="p">,</span><span class="s">&quot;(CHATILLON - MONTROUGE &lt;-&gt; ST-DENIS-UNIVERSITE/LES COURTILLES) - Aller&quot;</span><span class="p">,,</span><span class="m">1</span><span class="p">,,</span><span class="n">FFFFFF</span><span class="p">,</span><span class="m">000000</span>
<span class="m">1197622</span><span class="p">,</span><span class="m">100</span><span class="p">,</span><span class="s">&quot;13&quot;</span><span class="p">,</span><span class="s">&quot;(CHATILLON - MONTROUGE &lt;-&gt; ST-DENIS-UNIVERSITE/LES COURTILLES) - Retour&quot;</span><span class="p">,,</span><span class="m">1</span><span class="p">,,</span><span class="n">FFFFFF</span><span class="p">,</span><span class="m">000000</span>
<span class="m">1197623</span><span class="p">,</span><span class="m">100</span><span class="p">,</span><span class="s">&quot;13&quot;</span><span class="p">,</span><span class="s">&quot;(CHATILLON - MONTROUGE &lt;-&gt; ST-DENIS-UNIVERSITE/LES COURTILLES) - Retour&quot;</span><span class="p">,,</span><span class="m">1</span><span class="p">,,</span><span class="n">FFFFFF</span><span class="p">,</span><span class="m">000000</span>
</code></pre></div>

<h4>stops.txt</h4>
<p>Ce fichier liste les arrêts avec, éventuellement, quelques informations complémentaires. La RATP fournit l'adresse la plus proche de l'arrêt ainsi que les coordonnées GPS de son centre (dans le cas d'une station qui dispose de plusieurs sorties). À noter que ce fichier n'est pas ordonné selon le sens de parcours des courses sur la ligne.</p>
<blockquote>
<p>Une <strong>mission</strong> est un trajet parcouru par un ensemble de trains. Elle est décrite par :
<ul>
  <li> la gare de départ ;</li>
  <li> la gare d'arrivée ;</li>
  <li> les gares intermédiaires desservies (certains trajets peuvent « sauter » des gares).</li>
</ul>
Lorsqu'un train suit une mission, il réalise une <strong>course</strong>.</p>
</blockquote>
<p>Exemple des quatre premières stations de la ligne 13 :</p>
<div class="highlight"><pre><span></span><code><span class="err">stop_id,stop_code,stop_name,stop_desc,stop_lat,stop_lon,location_type,parent_station</span>
<span class="err">2397,,&quot;Pernety&quot;,&quot;Raymond Losserand (72 rue) - 75114&quot;,48.833933819810916,2.31790897216328,0,</span>
<span class="err">1969,,&quot;Châtillon Montrouge&quot;,&quot;République (220 avenue de la) - 92020&quot;,48.810283363510756,2.3012888709759522,0,</span>
<span class="err">2406,,&quot;Place de Clichy&quot;,&quot;Clichy (terre-plein face au 7 place de) - 75109&quot;,48.883203999876585,2.3272660246411383,0,</span>
<span class="err">...</span>
</code></pre></div>

<h4>trips.txt</h4>
<p>Ce fichier liste les courses et les associe à une route. Nous reviendrons sur son utilité en observant les horaires d'arrêt.</p>
<p>Exemple sur la ligne 13 :</p>
<div class="highlight"><pre><span></span><code><span class="err">route_id,service_id,trip_id,trip_headsign,trip_short_name,direction_id,shape_id</span>
<span class="err">1197620,1762288,10017622880912413,101,101,0,</span>
<span class="err">1197620,1762289,10017622890912413,101,101,0,</span>
<span class="err">1197620,1762292,10017622920912413,101,101,0,</span>
<span class="err">...</span>
</code></pre></div>

<h4>stops_times.txt</h4>
<p>Ce fichier présente les horaires des courses aux stations (points d'arrêt). Ce fichier est trié par course et par heure d'arrêt en station.</p>
<p>Un détail est à noter quant aux horaires : ceux-ci sont fournis pour la journée qui peut se terminer... le lendemain. Un métro circulant le dimanche à 1h du matin sera en réalité rattaché à la journée du samedi. Ainsi, son horaire ne sera pas « à 1h le dimanche » mais « à 25h le samedi ». Bien que cette astuce puisse sembler tordue, elle simplifie en pratique beaucoup de choses, notamment pour maintenir la continuité des courses : il serait absurde de scinder la course d'un train sous prétexte qu'il roule à cheval sur deux jours calendaires.</p>
<p>Exemple pour la ligne 13 :</p>
<div class="highlight"><pre><span></span><code><span class="err">trip_id,arrival_time,departure_time,stop_id,stop_sequence,stop_headsign,shape_dist_traveled</span>
<span class="err">10017622880912413,19:38:00,19:38:00,1969,1,,</span>
<span class="err">10017622880912413,19:40:00,19:40:00,1880,2,,</span>
<span class="err">10017622880912413,19:41:00,19:41:00,1879,3,,</span>
</code></pre></div>

<p>Dans cet exemple, pour la course présentée, le véhicule s'arrête à 19:38:00 à l'arrêt 1969 (Châtillon - Montrouge) et en repart à la même heure. On en déduira qu'on ne prend vraisemblabement pas en compte le temps d'arrêt en station. Il arrive ensuite à la station 1880 (Malakoff - Rue Etienne Dolet) à 19:40:00, puis à la station 1879 (Malakoff - Plateau de Vanves) à 19:41:00, etc.</p>
<h4>transfers.txt</h4>
<p><code>transfers.txt</code> regroupe les correspondances entre plusieurs points d'arrêt.</p>
<p>Ce fichier n'étant pas compréhensible par un humain, prenons un exemple et déroulons-le :</p>
<div class="highlight"><pre><span></span><code><span class="err">from_stop_id,to_stop_id,transfer_type,min_transfer_time</span>
<span class="err">4211780,2270,2,212</span>
<span class="err">4472773,1724,2,228</span>
<span class="err">3619167,2276,2,252</span>
</code></pre></div>

<p>Sur la première ligne, la correspondance se fait entre l'arrêt « 4211780 » et l'arrêt « 2270 ». Un recherche dans le fichier <code>stops.txt</code> permet de donner un nom humainement compréhensible à ces identifiants : ils correspondent ici tous les deux au point d'arrêt « Mairie de Saint-Ouen ».</p>
<p>À partir du l'identifiant d'un point d'arrêt, on peut également ressortir les identifiants de course (<code>trip_id</code>). Prenons-en un au hasard :</p>
<div class="highlight"><pre><span></span><code>$ grep <span class="m">2270</span> stop_times.txt <span class="p">|</span> cut -d, -f1 <span class="p">|</span> head -n1
<span class="m">10017622880912417</span>
</code></pre></div>

<p>À partir de cet identifiant, on peut retrouver la route associée (<code>route_id</code>) :</p>
<div class="highlight"><pre><span></span><code>$ grep <span class="m">10017622880912417</span> trips.txt <span class="p">|</span> cut -d, -f1
<span class="m">1197623</span>
</code></pre></div>

<p>On trouve donc qu'il s'agissait de la ligne 13 dans le sens « retour » :</p>
<div class="highlight"><pre><span></span><code>$ grep ^1197623, routes.txt
<span class="m">1197623</span>,100,<span class="s2">&quot;13&quot;</span>,<span class="s2">&quot;(CHATILLON - MONTROUGE &lt;-&gt; ST-DENIS-UNIVERSITE/LES COURTILLES) - Retour&quot;</span>,,1,,FFFFFF,000000
</code></pre></div>

<p>Vérifions par acquit de conscience l'autre identifiant de point d'arrêt :</p>
<div class="highlight"><pre><span></span><code>$ grep <span class="m">4211780</span> stop_times.txt <span class="p">|</span> cut -d, -f1 <span class="p">|</span> head -n1
<span class="m">119841521246955</span>
$ grep <span class="m">119841521246955</span> trips.txt
<span class="m">1364288</span>,1984152,119841521246955,,1,1,
$ grep <span class="m">1364288</span> routes.txt
<span class="m">1364288</span>,100,<span class="s2">&quot;N44&quot;</span>,<span class="s2">&quot;(GARGES-SARCELLES RER &lt;-&gt; GARE DE L&#39;EST) - Retour&quot;</span>,,3,,FFFFFF,000000
</code></pre></div>

<p>Il s'agit donc du <a href="http://www.ratp.fr/informer/pdf/orienter/f_horaire.php?fm=gif&amp;loc=noctilien&amp;nompdf=n44">Noctilien N44</a> qui passe effectivement par « Mairie de Saint-Ouen ». La boucle est bouclée.</p>
<h3>Parsing des fichiers GTFS</h3>
<p>Les fichiers GTFS, bien que portant l'extension <code>.txt</code> sont manipulables comme des fichiers CSV. Dans la suite, on utilisera des structures qui sont (presque) calquées sur le format de ces fichiers. Sur le principe, leur parsing est immédiat. Prenons par exemple le cas des routes (on utilise ici <a href="https://github.com/tototoshi/scala-csv">scala-csv</a>) :</p>
<div class="highlight"><pre><span></span><code><span class="k">import</span> <span class="nn">com.github.tototoshi.csv._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Route</span><span class="o">(</span><span class="n">routeId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">routeShortName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">routeLongName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">routeDesc</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Route</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">parse</span><span class="o">(</span><span class="n">fields</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Route</span><span class="o">(</span>
      <span class="n">fields</span><span class="o">(</span><span class="s">&quot;route_id&quot;</span><span class="o">).</span><span class="n">toLong</span><span class="o">,</span>
      <span class="n">fields</span><span class="o">(</span><span class="s">&quot;route_short_name&quot;</span><span class="o">),</span>
      <span class="n">fields</span><span class="o">(</span><span class="s">&quot;route_long_name&quot;</span><span class="o">),</span>
      <span class="n">fields</span><span class="o">(</span><span class="s">&quot;route_desc&quot;</span><span class="o">)</span>
    <span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">routes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Route</span><span class="o">]</span> <span class="k">=</span> <span class="nc">CSVReader</span><span class="o">.</span>
  <span class="n">open</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">&quot;routes.txt&quot;</span><span class="o">)).</span>
  <span class="n">allWithHeaders</span><span class="o">().</span>
  <span class="n">map</span><span class="o">(</span><span class="nc">Route</span><span class="o">.</span><span class="n">parse</span><span class="o">)</span>
</code></pre></div>

<p>Dans la pratique, la volumétrie des horaires des courses rend l'opération plus complexe :</p>
<div class="highlight"><pre><span></span><code>$ wc -l *
        <span class="m">2</span> agency.txt
    <span class="m">65937</span> calendar_dates.txt
     <span class="m">4578</span> calendar.txt
     <span class="m">1067</span> routes.txt
    <span class="m">26653</span> stops.txt
 <span class="m">10402381</span> stop_times.txt
    <span class="m">80338</span> transfers.txt
   <span class="m">417920</span> trips.txt
</code></pre></div>

<p>Pour simplifier la suite de cet article, nous ne traiterons que les lignes ferrées (métro et RER) exploitées par la RATP. On regroupera les données ligne par ligne (au sens RATP) dans la structure <code>GtfsData</code> pour ensuite les fusionner :</p>
<div class="highlight"><pre><span></span><code><span class="k">case</span> <span class="k">class</span> <span class="nc">GtfsData</span><span class="o">(</span>
  <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">routes</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Route</span><span class="o">],</span>
  <span class="n">trips</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Trip</span><span class="o">],</span>
  <span class="n">stops</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Stop</span><span class="o">],</span>
  <span class="n">stopTimes</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">StopTime</span><span class="o">],</span>
  <span class="n">transfers</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Transfer</span><span class="o">]</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">lines</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">GtfsData</span><span class="o">]</span> <span class="k">=</span> <span class="n">parseGtfsDataByLine</span><span class="o">()</span>
<span class="k">val</span> <span class="n">gtfsData</span> <span class="k">=</span> <span class="nc">GtfsData</span><span class="o">(</span>
  <span class="s">&quot;RATP&quot;</span><span class="o">,</span>
  <span class="n">lines</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">routes</span><span class="o">),</span>
  <span class="n">lines</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">trips</span><span class="o">),</span>
  <span class="n">lines</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">stops</span><span class="o">),</span>
  <span class="n">lines</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">stopTimes</span><span class="o">),</span>
  <span class="n">lines</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">transfers</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div>

<h3>Construction de la table horaire</h3>
<p>La table horaire est, comme nous l'avons vu, une séquence de connexions modélisées par des quadruplets contenants chacun la station de départ, la station d'arrivée, l'heure de départ et l'heure d'arrivée.</p>
<div class="highlight"><pre><span></span><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Timetable</span><span class="o">(</span><span class="n">connections</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Connection</span><span class="o">])</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Connection</span><span class="o">(</span>
  <span class="n">departureStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="n">arrivalStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="n">departureTimestamp</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="n">arrivalTimestamp</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span>
</code></pre></div>

<p>Sa construction se fait en deux étapes :</p>
<ol>
<li>en ingérant les connexions issues des courses (successions de points d'arrêts sur une même ligne) ;</li>
<li>en ingérant les connexions issues des correspondances (« ponts » entre les courses).</li>
</ol>
<h4>Connexions issues des courses</h4>
<p>On ingère les horaires des courses en les groupant par... course et en prenant soin de ne pas « mélanger » les horaires de deux courses. Prenons l'exemple ci-dessous : les ceux courses fréquentent la même ligne mais ne s'arrêtent pas aux mêmes arrêts. Il n'y a pas de correspondance entre les deux.</p>
<div class="highlight"><pre><span></span><code><span class="err"> Course I : A (t1) --------------------&gt; B (t3)</span>
<span class="err">Course II :               C (t2) --------------------&gt; D (t4)</span>
</code></pre></div>

<p>Le fichier <code>stop_times.txt</code> ressemblerait à :</p>
<div class="highlight"><pre><span></span><code><span class="err">trip_id,arrival_time,departure_time,stop_id,stop_sequence,stop_headsign,shape_dist_traveled</span>
<span class="err">I, t1, t1, A, 1, ,</span>
<span class="err">II, t2, t2, C, 1, ,</span>
<span class="err">I, t3, t3, B, 1, ,</span>
<span class="err">II, t4, t4, D, 1, ,</span>
</code></pre></div>

<p>Une lecture indépendante de l'identifiant de course (<code>trip_id</code>) amalgamerait donc ces deux courses et induirait de fausses correspondances.</p>
<p>La création de la table horaire se fait en groupant deux à deux les horaires d'arrêt au sein d'une même course. Pour chaque élément à l'indice <code>i</code>, on créera une connexion partant de l'arrêt à cet indice et arrivant à l'arrêt de l'indice <code>i+1</code>. On implémente cette construction avec une fonction récursive qui dépile un à un les horaires de course.</p>
<p>On utilise ici une fonction <em>tail recursive</em> (<a href="https://fr.wikipedia.org/wiki/R%C3%A9cursion_terminale">récursion terminale</a> en français), annotée <code>@tailrec</code>. Une telle fonction a la particularité de voir son appel récursif comme la dernière instruction à être évaluée. Son avantage est de pouvoir être « optimisée » par le compilateur en une itération (« boucle <code>for</code> »), nous libérant du risque de dépassement de capacité de la pile inhérent aux récursions.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">connectionsFromStopTimes</span> <span class="k">=</span> <span class="n">gtfsData</span><span class="o">.</span>
  <span class="n">stopTimesByTripId</span><span class="o">.</span>
  <span class="n">values</span><span class="o">.</span>
  <span class="n">flatMap</span><span class="o">(</span><span class="n">stopTimesToConnections</span><span class="o">)</span>

<span class="k">def</span> <span class="n">stopTimesToConnections</span><span class="o">(</span><span class="n">stopTimes</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">StopTime</span><span class="o">])</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nd">@tailrec</span>
  <span class="k">def</span> <span class="n">inner</span><span class="o">(</span><span class="n">stopTimes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">StopTime</span><span class="o">],</span> <span class="n">connections</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Connection</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">stopTimes</span> <span class="k">match</span> <span class="o">{</span>
      <span class="c1">// Aucun horaire (n&#39;arrive que si la collection initiale est vide).</span>
      <span class="c1">// On n&#39;a rien à faire de plus, on retourne les connexions (vides).</span>
      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">connections</span>
      <span class="c1">// Dernier horaire : il est connecté au précédent et n&#39;ira pas plus loin.</span>
      <span class="c1">// On en a terminé et on retourne les connexions.</span>
      <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">connections</span>
      <span class="c1">// Cas général : il reste des stations après la première de la collection.</span>
      <span class="c1">// On créé une connexion entre celle-ci et la première des suivantes.</span>
      <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">departureStop</span> <span class="k">=</span> <span class="n">head</span><span class="o">.</span><span class="n">stopId</span><span class="o">.</span><span class="n">toInt</span>
        <span class="k">val</span> <span class="n">arrivalStop</span> <span class="k">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">stopId</span><span class="o">.</span><span class="n">toInt</span>
        <span class="k">val</span> <span class="n">departureTime</span> <span class="k">=</span> <span class="n">durationToTimestamp</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="n">departureTime</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">arrivalTime</span> <span class="k">=</span> <span class="n">durationToTimestamp</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">departureTime</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">connection</span> <span class="k">=</span> <span class="nc">Connection</span><span class="o">(</span><span class="n">departureStop</span><span class="o">,</span> <span class="n">arrivalStop</span><span class="o">,</span> <span class="n">departureTime</span><span class="o">,</span> <span class="n">arrivalTime</span><span class="o">)</span>
        <span class="c1">// Étape suivante de la récursion</span>
        <span class="n">inner</span><span class="o">(</span><span class="n">tail</span><span class="o">,</span> <span class="n">connections</span> <span class="o">:+</span> <span class="n">connection</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">// Initialisation de la récursion</span>
  <span class="n">inner</span><span class="o">(</span><span class="n">stopTimes</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">List</span><span class="o">())</span>
<span class="o">}</span>
</code></pre></div>

<p>Dans cet exemple de code, la fonction <code>durationToTimestamp</code> retourne un timestamp correspondant à l'heure effective pour la journée en cours à partir de l'heure seule fournie dans les données. Par exemple, le 01/01/2016, la durée <code>19h32min27s</code> permettra d'obtenir le timestamp équivalent à <code>2016-01-01T19:32:27.0Z</code>.</p>
<h4>Connexions issues des correspondances</h4>
<p>Le fichier <code>transfers.txt</code> nous donne les correspondances disponibles sur une ligne. L'objectif de cette étape est :</p>
<ul>
<li>de ne conserver que les correspondances de notre réseau (dans cet exemple, nous ne travaillons pas sur les bus, nous les éliminons donc) ;</li>
<li>de créer toutes les entrées de la table horaire correspondant à cette correspondance.</li>
</ul>
<p>Le filtrage des correspondances est aisé avec notre structure de données. Nous disposons déjà de l'ensemble des stations du réseau. Il nous suffit de vérifier que ces correspondances ont lieu entre deux stations du réseau.</p>
<div class="highlight"><pre><span></span><code><span class="k">case</span> <span class="k">class</span> <span class="nc">GtfsData</span><span class="o">(...)</span> <span class="o">{</span>
  <span class="c1">// Indexation des stations du réseau</span>
  <span class="k">val</span> <span class="n">stopsByStopId</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Long</span><span class="p">,</span> <span class="kt">Stop</span><span class="o">]</span> <span class="k">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">stop</span> <span class="k">=&gt;</span> <span class="n">stop</span><span class="o">.</span><span class="n">stopId</span> <span class="o">-&gt;</span> <span class="n">stop</span><span class="o">)(</span><span class="n">collection</span><span class="o">.</span><span class="n">breakOut</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">filteredTransfers</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Transfer</span><span class="o">]</span> <span class="k">=</span> <span class="n">gtfsData</span><span class="o">.</span><span class="n">transfers</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">transfer</span> <span class="k">=&gt;</span>
  <span class="c1">// Filtrage des correspondances avec des stations hors du réseau</span>
  <span class="n">gtfsData</span><span class="o">.</span><span class="n">stopsByStopId</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">transfer</span><span class="o">.</span><span class="n">fromStopId</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">gtfsData</span><span class="o">.</span><span class="n">stopsByStopId</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">transfer</span><span class="o">.</span><span class="n">toStopId</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div>

<p>Cela étant fait, pour chacune de ces correspondances, on créé dans la table horaire une connexion correspondant à chaque horaire de passage à cette station. On utilisera pour cela les données issues de <code>stop_times.txt</code>. Cette fonction est très similaire dans son fonctionnement à <code>stopTimesToConnections</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="n">transfersToConnections</span><span class="o">(</span><span class="n">filteredTransfers</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Transfer</span><span class="o">])</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nd">@tailrec</span>
  <span class="k">def</span> <span class="n">inner</span><span class="o">(</span><span class="n">transfers</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Transfer</span><span class="o">],</span> <span class="n">connections</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Connection</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">transfers</span> <span class="k">match</span> <span class="o">{</span>
      <span class="c1">// Aucune correspondance à traiter. On en a terminé et on sort avec</span>
      <span class="c1">// la liste construite jusqu&#39;ici.</span>
      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">connections</span>
      <span class="c1">// Il reste au moins une correspondance à traiter (tail peut être Nil).</span>
      <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">departureStop</span> <span class="k">=</span> <span class="n">head</span><span class="o">.</span><span class="n">fromStopId</span>
        <span class="k">val</span> <span class="n">arrivalStop</span> <span class="k">=</span> <span class="n">head</span><span class="o">.</span><span class="n">toStopId</span>
        <span class="c1">// Pour chaque horaire de train à cette station, on créé</span>
        <span class="c1">// une entrée dans la table horaire.</span>
        <span class="k">val</span> <span class="n">transferConnections</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="n">gtfsData</span><span class="o">.</span>
          <span class="n">stopTimesByStopId</span><span class="o">(</span><span class="n">departureStop</span><span class="o">).</span>
          <span class="n">map</span><span class="o">(</span><span class="n">stopTime</span> <span class="k">=&gt;</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">connectionDepartureTime</span> <span class="k">=</span> <span class="n">durationToTimestamp</span><span class="o">(</span><span class="n">stopTime</span><span class="o">.</span><span class="n">arrivalTime</span><span class="o">)</span>
            <span class="nc">Connection</span><span class="o">(</span>
              <span class="n">departureStop</span><span class="o">,</span>
              <span class="n">arrivalStop</span><span class="o">,</span>
              <span class="n">connectionDepartureTime</span><span class="o">,</span>
              <span class="n">connectionDepartureTime</span> <span class="o">+</span> <span class="n">head</span><span class="o">.</span><span class="n">minTransferTime</span>
            <span class="o">)</span>
          <span class="o">})</span>
        <span class="c1">// Étape suivante de la récursion.</span>
        <span class="n">inner</span><span class="o">(</span><span class="n">tail</span><span class="o">,</span> <span class="n">connections</span> <span class="o">++</span> <span class="n">transferConnections</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">// Initialisation de la récursion.</span>
  <span class="n">inner</span><span class="o">(</span><span class="n">filteredTransfers</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">List</span><span class="o">())</span>
<span class="o">}</span>
</code></pre></div>

<h4>Fusion des deux tables horaires</h4>
<p>On a construit jusqu'ici deux tables horaires :</p>
<ul>
<li>l'une issue des horaires des trains en station ;</li>
<li>l'autre issue des correspondances entre les trains.</li>
</ul>
<p>Reste maintenant à fusionner les deux. N'oublions pas que cette table doit être triée par heure de départ croissante. À ce détail près, cette étape est immédiate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">connectionsFromStopTimes</span> <span class="k">=</span> <span class="n">gtfsData</span><span class="o">.</span>
  <span class="n">stopTimesByTripId</span><span class="o">.</span>
  <span class="n">values</span><span class="o">.</span>
  <span class="n">flatMap</span><span class="o">(</span><span class="n">stopTimesToConnections</span><span class="o">)</span>
<span class="k">val</span> <span class="n">connectionsFromTransfers</span> <span class="k">=</span> <span class="n">transfersToConnections</span><span class="o">(</span><span class="n">gtfsData</span><span class="o">)</span>

<span class="k">val</span> <span class="n">connections</span> <span class="k">=</span> <span class="o">(</span><span class="n">connectionsFromStopTimes</span> <span class="o">++</span> <span class="n">connectionsFromTransfers</span><span class="o">).</span>
  <span class="n">toList</span><span class="o">.</span>
  <span class="n">sortBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">departureTimestamp</span><span class="o">)</span>
</code></pre></div>

<h2>Implémentation de l'algorithme</h2>
<p>Je propose ici une implémentation en Scala qui pourrait probablement être (largement, rien que par sa mutabilité) améliorée. Partons toujours de là.</p>
<h3>API</h3>
<p>Cette implémentation est paramétrée par :</p>
<ul>
<li>la table horaire ;</li>
<li>un dictionnaire des arrêts indexés par leur identifiant.</li>
</ul>
<p>Le calcul d'itinéraire (méthode <code>compute</code>) prend en entrée :</p>
<ul>
<li>un arrêt de départ ;</li>
<li>un arrêt d'arrivée ;</li>
<li>une heure de départ.</li>
</ul>
<p>Il retourne la liste des connexions optimales pour effectuer ce trajet.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">CSA</span><span class="o">(</span><span class="n">timetable</span><span class="k">:</span> <span class="kt">Timetable</span><span class="o">,</span> <span class="n">stopsByStopId</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Stop</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">compute</span><span class="o">(</span><span class="n">departureStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">arrivalStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">departureTime</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div>

<h3>Initialisation</h3>
<p>On initialise les tableaux avec une valeur « virtuellement infinie » (valeur maximale qu'un entier peut représenter) à l'exception de l'heure d'arrivée optimale à la station de départ... puisque cette valeur est connue.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inConnection</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">CSA</span><span class="o">.</span><span class="nc">MaxStations</span><span class="o">)(</span><span class="nc">Int</span><span class="o">.</span><span class="nc">MaxValue</span><span class="o">)</span>
<span class="k">val</span> <span class="n">earliestArrival</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">CSA</span><span class="o">.</span><span class="nc">MaxStations</span><span class="o">)(</span><span class="nc">Int</span><span class="o">.</span><span class="nc">MaxValue</span><span class="o">)</span>

<span class="k">def</span> <span class="n">compute</span><span class="o">(</span><span class="n">departureStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">arrivalStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">departureTime</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">earliestArrival</span><span class="o">(</span><span class="n">departureStation</span><span class="o">)</span> <span class="k">=</span> <span class="n">departureTime</span>
  <span class="c1">// [...]</span>
<span class="o">}</span>
</code></pre></div>

<h3>Calcul du trajet</h3>
<h4>Vue macroscopique</h4>
<p>On retrouve les deux étapes du calcul dans la méthode <code>compute</code> :</p>
<ul>
<li>la première qui parcourt les connexions et détermine l'heure d'arrivée optimale pour chaque station (<code>scanTimetable</code>) ;</li>
<li>la seconde qui, à partir de cette table des connexions optimales, reconstruit le trajet (<code>computeRoute</code>).</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="n">compute</span><span class="o">(</span><span class="n">departureStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">arrivalStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">departureTime</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">earliestArrival</span><span class="o">(</span><span class="n">departureStation</span><span class="o">)</span> <span class="k">=</span> <span class="n">departureTime</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">departureStation</span> <span class="o">&lt;=</span> <span class="nc">CSA</span><span class="o">.</span><span class="nc">MaxStations</span> <span class="o">&amp;&amp;</span> <span class="n">arrivalStation</span> <span class="o">&lt;=</span> <span class="nc">CSA</span><span class="o">.</span><span class="nc">MaxStations</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">scanTimetable</span><span class="o">(</span><span class="n">arrivalStation</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">computeRoute</span><span class="o">(</span><span class="n">arrivalStation</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>

<h4>Parcours de la table horaire</h4>
<p>On utilise une fois de plus une récursion terminale.</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span> <span class="k">def</span> <span class="n">scanTimetable</span><span class="o">(</span><span class="n">arrivalStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nd">@tailrec</span>
  <span class="k">def</span> <span class="n">inner</span><span class="o">(</span><span class="n">conns</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">Connection</span><span class="p">,</span> <span class="kt">Int</span><span class="o">)],</span> <span class="n">earliest</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">newEarliest</span> <span class="k">=</span> <span class="n">earliest</span>
    <span class="n">conns</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Seq</span><span class="o">()</span> <span class="k">=&gt;</span>
        <span class="c1">// Aucune connexion dans la table horaire.</span>
        <span class="c1">// Ce n&#39;est pas le cas le plus intéressant mais il n&#39;y a rien à faire.</span>
        <span class="o">()</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">connection</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span> <span class="o">+:</span> <span class="k">_</span> <span class="k">if</span> <span class="n">connection</span><span class="o">.</span><span class="n">arrivalTimestamp</span> <span class="o">&gt;</span> <span class="n">earliest</span> <span class="k">=&gt;</span>
        <span class="c1">// L&#39;heure d&#39;arrivée de la connexion dépasse l&#39;heure d&#39;arrivée « optimale » actuelle.</span>
        <span class="c1">// On ne fait rien.</span>
        <span class="o">()</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">connection</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span> <span class="o">+:</span> <span class="n">tail</span> <span class="k">=&gt;</span>
        <span class="c1">// La connexion optimise les horaires déjà calculés. On met à jour les horaires.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">leavesAfterArrival</span><span class="o">(</span><span class="n">connection</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">optimizesArrivalTime</span><span class="o">(</span><span class="n">connection</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">earliestArrival</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="n">arrivalStation</span><span class="o">)</span> <span class="k">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">arrivalTimestamp</span>
          <span class="n">inConnection</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="n">arrivalStation</span><span class="o">)</span> <span class="k">=</span> <span class="n">index</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="n">arrivalStation</span> <span class="o">==</span> <span class="n">arrivalStation</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">newEarliest</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="n">earliest</span><span class="o">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">arrivalTimestamp</span><span class="o">)</span>
          <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">inner</span><span class="o">(</span><span class="n">tail</span><span class="o">,</span> <span class="n">newEarliest</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">inner</span><span class="o">(</span><span class="n">timetable</span><span class="o">.</span><span class="n">connections</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">,</span> <span class="nc">Int</span><span class="o">.</span><span class="nc">MaxValue</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">private</span> <span class="k">def</span> <span class="n">leavesAfterArrival</span><span class="o">(</span><span class="n">connection</span><span class="k">:</span> <span class="kt">Connection</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">connection</span><span class="o">.</span><span class="n">departureTimestamp</span> <span class="o">&gt;=</span> <span class="n">earliestArrival</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="n">departureStation</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">private</span> <span class="k">def</span> <span class="n">optimizesArrivalTime</span><span class="o">(</span><span class="n">connection</span><span class="k">:</span> <span class="kt">Connection</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">connection</span><span class="o">.</span><span class="n">arrivalTimestamp</span> <span class="o">&lt;</span> <span class="n">earliestArrival</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="n">arrivalStation</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>

<h4>Construction de l'itinéraire à partir de la table horaire</h4>
<p>Une fois la table horaire <code>inConnection</code> calculée, on reconstitue l'itinéraire inversé en partant de la station d'arrivée et en remontant jusqu'à la station de départ.</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span> <span class="k">def</span> <span class="n">computeRoute</span><span class="o">(</span><span class="n">arrivalStation</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">inConnection</span><span class="o">(</span><span class="n">arrivalStation</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Int</span><span class="o">.</span><span class="nc">MaxValue</span> <span class="k">=&gt;</span>
      <span class="nc">Seq</span><span class="o">()</span> <span class="c1">// Pas de solution</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">var</span> <span class="n">route</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Connection</span><span class="o">]()</span>
      <span class="k">var</span> <span class="n">lastConnectionIndex</span> <span class="k">=</span> <span class="n">inConnection</span><span class="o">(</span><span class="n">arrivalStation</span><span class="o">)</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">lastConnectionIndex</span> <span class="o">!=</span> <span class="nc">Int</span><span class="o">.</span><span class="nc">MaxValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">connection</span><span class="k">:</span> <span class="kt">Connection</span> <span class="o">=</span> <span class="n">timetable</span><span class="o">.</span><span class="n">connections</span><span class="o">(</span><span class="n">lastConnectionIndex</span><span class="o">)</span>
        <span class="n">route</span> <span class="k">=</span> <span class="n">route</span> <span class="o">:+</span> <span class="n">connection</span>
        <span class="n">lastConnectionIndex</span> <span class="k">=</span> <span class="n">inConnection</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="n">departureStation</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="n">route</span><span class="o">.</span><span class="n">reverse</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>Ce cas est volontairement écrit en « Java++ » plutôt qu'en « bon Scala » par simplicité de lecture. Saurez-vous écrire le cas général en une ligne (ou deux) ?</p>
<h3>Exemple</h3>
<p>Partons d'un trajet entre Maubert-Mutualité et Voltaire en partant à 18h.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maubert</span> <span class="k">=</span> <span class="mi">2350</span>
<span class="k">val</span> <span class="n">voltaireLeonBlum</span> <span class="k">=</span> <span class="mi">1633</span>

<span class="n">csa</span><span class="o">.</span><span class="n">compute</span><span class="o">(</span>
  <span class="n">maubert</span><span class="o">,</span>
  <span class="n">voltaireLeonBlum</span><span class="o">,</span>
  <span class="n">durationToTimestamp</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">ofHours</span><span class="o">(</span><span class="mi">18</span><span class="o">))</span>
<span class="o">)</span>
</code></pre></div>

<p>On obtient le trajet (notez la présence des connexions de correspondance à Odéon et Strasbourg-Saint-Denis) :</p>
<div class="highlight"><pre><span></span><code><span class="err">Solution found with 15 connections</span>
<span class="err">  Maubert-Mutualité -&gt; Cluny-La Sorbonne</span>
<span class="err">  Cluny-La Sorbonne -&gt; Odéon</span>
<span class="err">  Odéon -&gt; Odéon</span>
<span class="err">  Odéon -&gt; Saint-Michel</span>
<span class="err">  Saint-Michel -&gt; Cité</span>
<span class="err">  Cité -&gt; Châtelet</span>
<span class="err">  Châtelet -&gt; Les Halles</span>
<span class="err">  Les Halles -&gt; Etienne Marcel</span>
<span class="err">  Etienne Marcel -&gt; Réaumur-Sébastopol</span>
<span class="err">  Réaumur-Sébastopol -&gt; Strasbourg-Saint-Denis</span>
<span class="err">  Strasbourg-Saint-Denis -&gt; Strasbourg-Saint-Denis</span>
<span class="err">  Strasbourg-Saint-Denis -&gt; République</span>
<span class="err">  République -&gt; Oberkampf</span>
<span class="err">  Oberkampf -&gt; Saint-Ambroise</span>
<span class="err">  Saint-Ambroise -&gt; Voltaire (Léon Blum)</span>
<span class="err">Total transit time: 21 minutes</span>
</code></pre></div>

<h2>Conclusion</h2>
<p>En comparaison, l'<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra">algorithme de plus court chemin de Dijkstra</a> présente une complexité proportionnelle à <em>C.log(N)</em> où <em>N</em> est le nombre de stations et <em>C</em> le nombre de correspondances entre deux stations, soit environ <em>N.log(N)</em> dans notre évaluation, tout en occupant un espace mémoire de taille proportionnelle à <em>N</em>.</p>
<p>Le métro parisien est constitué de 303 stations (<em>N = 303</em> et <em>N.log(N) = 752</em>) : on reste donc dans le même ordre de magnitude sur ces deux algorithmes au moment du calcul d'itinéraire. En revanche, le <em>Connexion scan algorithm</em> demande de pré-calculer la table horaire : il induit donc un coût préalable. Cette table pré-calculée le rend également moins souple : elle rend plus difficile le paramétrage de l'algorithme en fonction des préférences du voyageur. La facilité de marche du voyageur peut par exemple être utilisée pour pondérer la durée d'une correspondance :</p>
<ul>
<li>avec le CSA, il est nécessaire de calculer une table prenant en compte ce paramètre (une correspondance étant une connexion comme une autre) ;</li>
<li>avec l'algorithme de Dijkstra, il « suffit » d'associer un poids plus fort aux arêtes représentant une correspondance lorsque le voyageur a des difficultés à se déplacer.</li>
</ul>
<p>Si le CSA est plus simple à implémenter, il l'est au détriment de la souplesse en première approche. Il est cependant possible de typer les connexions de correspondance pour leur attribuer différentes heures d'arrivée en fonction de la vélocité pédestre du voyageur.</p>
<p>Enfin, si cet exemple a été mené sur le réseau ferré RATP d'Île de France, son extension au réseau de bus (347 lignes) n'est pas viable : la table horaire devient trop volumineuse pour tenir en mémoire et les performances s'en ressentent. Mon intuition est que cet algorithme est très pertinent sur de « petites » tables horaires (jusqu'à quelques centaines de stations). Dès que le réseau grossit, en revanche, il est préférable de chercher un autre algorithme moins gourmand en mémoire et en pré-calcul.</p>
      </div>
      <footer class="post-footer">
        <div class="meta">
            Posté dans «<a href="https://www.dericbourg.net/category/blog.html">Blog</a>» 
            par <a href="https://www.dericbourg.net/author/alban-dericbourg.html">Alban Dericbourg</a><br />
            Mots-clés:  #<a href="https://www.dericbourg.net/tag/opendata.html">opendata</a> #<a href="https://www.dericbourg.net/tag/ratp.html">ratp</a> #<a href="https://www.dericbourg.net/tag/gtfs.html">gtfs</a> #<a href="https://www.dericbourg.net/tag/scala.html">scala</a>        </div>
      </footer>
      <hr />
      <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'dericbourg'; // required: replace example with your forum shortname

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
      </article> <!-- /#page-main -->

        <aside id="page-side">
          <!-- begin includes/sidebar.html -->
          <nav>
            <h3>Liens</h3>
            <ul>
              <li><a href="https://github.com/adericbourg">GitHub</a></li>
              <li><a href="https://www.linkedin.com/in/adericbourg/">LinkedIn</a></li>
              <li><a href="https://twitter.com/adericbourg">Twitter</a></li>
            </ul>
          </nav>
          <!-- end includes/sidebar.html --></aside> <!-- /#page-side -->
      </div>  <!-- /#page-body -->

      <footer id="page-foot">
        <p> Powered by <a href="http://pelican.readthedocs.org">Pelican</a></p>
      </footer>
    </div> <!-- /#page -->
  </body>
</html>